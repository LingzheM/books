# テスト駆動開発サイクルの始め方
## はじめに

第1章で説明したTDDのプロセスでは、新機能のテストを既存のインフラに差し込むだけでシステムを育てられることを前提にしています。では、そのインフラがまだない「最初の機能」はどうするのでしょうか。受け入れテストとして、必要なフィードバックを得るには外部インターフェースを含めたエンドツーエンドで実行しなければなりません。つまり、自動化されたビルド／デプロイ／テストの一連のサイクルをすべて実装しておく必要があります。最初のテストが失敗する様子を目にする前に、やることは山ほどあるのです。

プロジェクトの最初からデプロイとテストまで行うことは、チームに自分たちのシステムが世の中にどう適合するのかを理解させます。これにより、「未知の未知」の技術的・組織的リスクが早期に洗い出され、手遅れになる前に対処できます。デプロイに取り組むことで、システム管理者や外部ベンダーなど、誰と連携すべきかも明らかになり、関係構築を始められます。

「まだ存在しないシステム」で「ビルド、デプロイ、テスト」から始めるのは奇妙に聞こえるかもしれませんが、私たちはこれを不可欠だと考えます。後回しにするリスクが高すぎるからです。私たちは、数か月の開発の末にシステムを安定してデプロイできず、プロジェクトが中止された事例を見てきました。新機能の追加に毎回数か月の手作業による回帰テストが必要になり、それでもエラー率が高すぎて、最終的にシステムが捨てられた例もあります。いつもどおり、私たちはフィードバックを基本的なツールだと捉えており、できるだけ早い段階で正しい方向に進めているかを知りたいのです。いったん最初のテストが整えば、その後のテストはずっと手早く書けるようになります。

---

## まず「ウォーキングスケルトン」をテストする

最初の受け入れテストを書いて通すときの悩ましさは、テスト対象の機能と、それを支えるツール群（インフラ）を同時に作らなければならない点にあります。片方の変更がもう片方の進捗を乱し、アーキテクチャ・テスト・本番コードがすべて動いている最中は、失敗原因の特定も難しくなります。不安定な開発環境の典型的な兆候は、失敗時に「最初にどこを見ればよいか」が明確でないことです。

この「最初の機能のパラドックス」を断ち切るには、問題を2つに分解します。まず「ウォーキングスケルトン（walking skeleton）」をビルド／デプロイ／テストする方法を確立し、そのインフラを使って最初の意味のある機能の受け入れテストを書きます。これができれば、残りのシステムはテスト駆動で開発できる土台が整います。

「ウォーキングスケルトン」とは、エンドツーエンドで自動ビルド・デプロイ・テスト可能な、実機能の最小スライスの実装を指します。自動化、主要コンポーネント、通信メカニズムを「最初の機能」に着手できるだけの最小限に含めます。スケルトンのアプリケーション機能自体は、誰の目にも明らかで退屈なほど単純にして、インフラに集中できるようにします。たとえば、データベースを背後に持つWebアプリなら、データベースのフィールドを表示するだけの平坦なWebページがスケルトンになります。第10章では、UIに単一の値を表示し、サーバーにはハンドシェイクメッセージだけを送る例を示します。

また、「エンドツーエンド」の「エンド」はシステムだけでなく**プロセス**も意味することを理解することが重要です。テストは白紙状態から始め、デプロイ可能なシステムをビルドし、本番相当の環境にデプロイし、そのデプロイ済みシステム経由でテストを実行したいのです。テストプロセスにデプロイ工程を含めることが重要なのは2つの理由からです。第1に、デプロイは手作業ではエラーが起きやすい作業なので、本番デプロイの時点までにスクリプトが十分に鍛えられているべきだからです。私たちが繰り返し学んだ教訓は、**自動化しようとすると、そのプロセスをいちばんよく理解できる**ということです。第2に、この局面はしばしば、開発チームが組織の他部門と接触し、その運用を学ぶ瞬間になります。もしデータベースのセットアップに「6週間と4つの承認」が必要なら、納期の2週間前ではなく**今**知っておくべきです。

もちろん現実には、真のエンドツーエンドテストがあまりに難しく、まずは「本物のシステムが何をし、どんな環境に置かれるか」という現時点の理解に基づくインフラから着手せざるを得ないこともあります。ただし、それはあくまで**つなぎ**であり、やり切るまでの一時しのぎであって、テストが本当にエンドツーエンドで走るまで未知のリスクは残ると心に留めておきます。Part III の Auction Sniper の例の弱点の1つは、テストが実サイトではなくダミーサーバーに対して実行されている点です。ローンチ前のどこかの時点で Southabee’s On-Line に対するテストが必要であり、それが早ければ早いほど、予期せぬ事態に対して容易に対処できます。

「ウォーキングスケルトン」を作っている間は、構造に集中し、テストを美しく表現的に整えることに過度にこだわりません。ウォーキングスケルトンとそれを支えるインフラは、テスト駆動開発を**どのように始めるか**を見極めるためのものです。これは完全なエンドツーエンド受け入れテスト解法への**最初の一歩**にすぎません。最初の機能のテストを書く段になったら、「読みたくなるテストを書く（write the test you want to read）」ことを心がけ、システムの振る舞いを明確に表現できるようにします。

> 早期のエンドツーエンドテストの重要性

>> 私たちが参加したあるプロジェクトは、数年間稼働していたにもかかわらず、システム全体をエンドツーエンドでテストしたことがありませんでした。本番障害は頻発し、デプロイもしばしば失敗していました。システムは、その管理対象である複雑なビジネストランザクションを反映して大規模かつ複雑でした。自動化されたエンドツーエンドのテストスイートを構築する労力はあまりに大きく、その作業のために新しいチームを丸ごと立ち上げる必要がありました。エンドツーエンドのテスト環境を作るだけで数か月を要し、結局、システム全体をエンドツーエンドのテストスイートで網羅することはできませんでした。

>> エンドツーエンドテストの必要性が設計に織り込まれていなかったため、システムはテストしにくい状態でした。たとえば、各コンポーネントは内部タイマーで処理をスケジュールしており、その一部は数日から数週間先に設定されていました。これではエンドツーエンドのテストを書きにくくなります。リアルタイムでテストを走らせるのは非現実的ですが、スケジューリングをシステム外部から制御する手段がなかったからです。そこで開発者は、定期的な処理がリモートスケジューラから送られるメッセージでトリガーされるように、システム自体を再設計しました。リモートスケジューラはテスト環境で差し替え可能です。これは重要なアーキテクチャ変更であり、しかもエンドツーエンドのテストカバレッジがない状況で実施せざるを得なかったため、非常にリスキーでした。

---
## ウォーキングスケルトンの形を決める

「ウォーキングスケルトン」の開発は、アプリケーションの高レベルな構造について意思決定を始めるタイミングです。全体の構造をある程度イメージできなければ、ビルド／デプロイ／テストのサイクルを自動化することはできません。細部までは不要ですが、初回リリースを支える主要なシステムコンポーネントが何で、どのように連携するかという大づかみの全体像は必要です。経験則として、ウォーキングスケルトンの設計は、ホワイトボードに数分で描ける程度であるべきだと考えます。

この初期構造を設計するには、システムの目的をある程度理解していなければなりません。さもないと、全取り組みが意味を失いかねません。選択の指針とするために、クライアントの要求（機能要件・非機能要件）の高レベルな見取り図が必要です。こうした準備作業はプロジェクトの立ち上げ（チャータリング）の一部ですが、本書の対象範囲外とします。

ウォーキングスケルトンの要点は、最初のテストを書くことを通じてプロジェクトのコンテキストを引き出し、チームが解決策の地図を描けるようにすること、すなわちコードを書く前に必ず決めておくべき本質的な意思決定を明確化することにあります。Figure 4.2 は、Figure 1.2 で示したTDDプロセスがこのコンテキストにどう当てはまるかを示しています。


アジャイル開発コミュニティで評判の悪い「Big Design Up Front（BDUF）」と混同しないでください。私たちは、コーディング開始前に設計全体をクラスやアルゴリズムのレベルまで詳細化しようとしているわけではありません。現時点のアイデアは多くが間違っている可能性が高いため、システムを育てながら詳細を見つけていくほうを選びます。私たちが行うのは、TDDサイクルを立ち上げるために必要な最小限の意思決定だけです。そうすることで、実際のフィードバックから学び、改善を始められるようにします。

---

## フィードバックの源を構築する

私たちがアプリケーションの設計について下した判断や、その前提が正しいという保証はありません。最善は尽くしますが、唯一頼れるのは、できるかぎり早く検証すること——すなわちプロセスにフィードバックの仕組みを組み込むことです。「ウォーキングスケルトン」を実装するために作るツールは、この学習プロセスを支えるためのものです。もちろん、それらのツールも最初から完璧ではありません。チームをどれだけ支援できているかを学びながら、段階的に改良していくことを想定します。

理想は、チームが Figure 4.3 のように実際の本番システムへ定期的にリリースできる状態です。これにより、システムのステークホルダーは自分たちのニーズにどれだけ合致しているかを評価できる一方で、私たちは実装の出来を判断できます。

私たちはビルドとテストの自動化を使って、システムの特性についてのフィードバックを得ます。たとえば、どれだけ容易にバージョンを切ってデプロイできるか、設計がどれほど有効に機能しているか、コード品質はどうか、といった点です。自動化されたデプロイは実ユーザーへの頻繁なリリースを後押しし、ドメイン理解の的確さや、実際にシステムを目にしたことで顧客の優先順位が変化したかどうかについてのフィードバックをもたらします。

最大の利点は、得られた知見に応じて変更できることです。あらゆるものをテストファーストで書くことで、網羅的な回帰テスト群を手にできるからです。無論、テストが完璧であることはありませんが、実務上は十分に厚いテストスイートがあれば、大規模な変更でも安全に実施できると私たちは考えます。

---

# 不確実性を早期に明らかにする

ここまでの取り組みにより、ほとんど何もしないはずの「ウォーキングスケルトン」を動かすまでに想定以上の時間がかかることに、チームがしばしば驚くのは当然です。最初の一歩では、多くのインフラを整え、厄介な問いを数多く投げかけ（そして答え）る必要があるからです。最初のいくつかの機能を実装するまでの時間は、チームが要件や対象環境について理解を深めるにつれて予測しにくくなります。新しいチームの場合は、うまく協働する方法を学ぶことによる社会的なストレスが、これに拍車をかけます。

同僚の Fred Tingey は、段階的開発に慣れていないチームやマネジメントにとって、それが不安を招くのは、プロジェクトのストレスを前倒しにするからだと指摘しました。遅延統合のプロジェクトは、最初は穏やかに始まりますが、チームが初めてシステム全体をまとめ上げようとする終盤になると、たいてい難易度が跳ね上がります。遅延統合は予測不能です。限られた時間と予算で数多くの可動部品を組み上げ、失敗を修復しなければならないからです。その結果、経験豊富なステークホルダーほど、段階的プロジェクトの立ち上がり時の不安定さに悪い反応を示しがちです。終盤はもっと悪化するはずだと予期するからです。

私たちの経験では、適切に運営された段階的開発はこれと逆の軌跡をたどります。立ち上がりは落ち着きませんが、いくつかの機能が実装され、プロジェクトの自動化が整ってくると、次第にルーチン化します。納品が近づく頃には、機能を着実に生み出す「終盤戦」になります。初回リリース前に活動が一時的に活発化することはあっても、デプロイやアップグレードのような退屈だが脆い作業は自動化され、「ただ動く」状態になっているはずです。対比はちょうど Figure 4.4 のような姿になります。

この側面を含め、テスト駆動開発は直観に反して見えるかもしれません。しかし、私たちは常に、システムの基本（少なくとも最初の叩き台）を十分な時間をかけて構造化し、自動化する価値があると考えています。もちろん、プロジェクト全体を「完璧なウォーキングスケルトン」の整備に費やすべきではありません。決定はホワイトボードレベルにとどめ、必要に応じて考えを改める権利を確保します。最も重要なのは、進むべき方向感と、前提を検証できる具体的な実装を持つことです。

「ウォーキングスケルトン」は、プロジェクトの早い段階で問題を炙り出します。その時点なら、対処するための時間も予算も、そして善意（協力的な空気）も、まだ残っているのです。

---

# ブラウンフィールド開発

私たちは常に、ゼロから新しいシステムを構築できるわけではありません。多くのプロジェクトは、既存システムを拡張・適応・置換するところから始まります。このような場合、「ウォーキングスケルトン」を一から作ることはできず、たとえ構造がどれだけ扱いづらくても、既存の資産を前提に進めなければなりません。

とはいえ、既存システムでTDDを立ち上げる手順は、新規システムに適用する場合と本質的には変わりません――すでに抱えている技術的負債のせいで、難易度は桁違いに上がり得ますが。Michael Feathers はこのテーマについて1冊丸ごと著しています（[Feathers04]）。

リグレッション（退行）を検知するテストがない状態でシステムの作り直しに着手するのはリスキーです。TDDを開始するいちばん安全な方法は、まずビルドとデプロイのプロセスを自動化し、そのうえで、変更が必要なコード領域をカバーするエンドツーエンドテストを追加することです。その防護があれば、内部品質の課題により自信を持って取り組めます。具体的には、機能を追加しながらコードをリファクタリングし、ユニットテストを導入していきます。

エンドツーエンドのテスト基盤を作り始める最も簡単な方法は、システムを通る**最も単純なパス**を見つけてそこから着手することです。これは「ウォーキングスケルトン」と同じ発想で、より複雑な機能のテストという難題に取り組む前に、周辺の支援インフラを段階的に整備することを可能にします。

---
