# 第5章　テスト駆動のサイクルを維持する

## Introduction（導入）

いったんTDDのプロセスを立ち上げたら、それをスムーズに回し続ける必要があります。この章では、いったん始まった TDD プロセスがどのように回るのかを示す。以降の本では、それをいかに円滑に動かすか――つまり、システムを構築しながらテストを書く方法、内部品質と外部品質の問題について早期フィードバックを得る方法、そしてテストが変更を支援し続け、今後の開発の障害にならないようにする方法――を詳しく掘り下げていく。

---

## 各機能は**受け入れテスト**から始める

新しい機能に着手するときは、**その機能がまだ存在しないことを示す失敗する受け入れテスト**を書き、完了までの進捗を追跡します（図5.1）。テストは**アプリケーションのドメイン用語だけ**を使い、**データベース**や**Webサーバ**などの技術用語は避けます。

これは、実装に関する当初の仮定に縛られたり、技術的な詳細でテストを複雑にしたりせずに、システムが何をすべきかを理解する助けになる。また、受け入れテスト群をシステムの技術インフラの変更から守ってくれる。たとえば、サードパーティが自社サービスのプロトコルを FTP とバイナリファイルから Web サービスと XML に変更したとしても、アプリケーションロジックのためのテストを作り直す必要はないはずだ。

このようなテストをコーディング前に書くと、何を達成したいのかを明確化させられることが分かっている。自動で検査できる形で要件を表現する際の精度が、暗黙の前提をあぶり出してくれるからだ。失敗しているテストは、そこで述べられている限られた機能の実装に集中させ、成果物を届けられる確率を高めてくれる。さらに言えば、テストから始めることは、システムをユーザー視点で見ることにつながる。実装者の視点から機能を推測するのではなく、ユーザーが何を必要としているのかを理解するのだ。

一方、**ユニットテスト**はオブジェクト（または小さな集まり）を**単体**で検証します。クラス設計の助けになり、動作の確信も与えてくれるが、それらがシステム全体の中で連携して動くかどうかは何も語らない。受け入れテストは、ユニットテスト済みのオブジェクトの統合を検証すると同時に、プロジェクトを前へと押し進める。

---

## 進捗を測るテストとリグレッションを捕まえるテストを分ける

新機能を記述するために受け入れテストを書くとき、私たちはそれらが実装完了まで失敗し続けることを想定している。新しい受け入れテストは、まだやるべき作業を表す。受け入れテストを赤から緑に変えていく活動は、チームがどれだけ前進しているかの指標になる。「フィードバックは基本ツール」（p.4）で説明した入れ子のプロジェクト・フィードバック・ループを駆動するエンジンだ。いったん合格した受け入れテストは、完成済みの機能を表し、再び失敗すべきではない。失敗したなら、リグレッション――既存コードを壊した――ということだ。

テスト群は、その役割の違いが反映されるように編成する。

* **ユニット／統合テスト**：開発チームを支えるもので、高速に実行され、常に合格しているべきだ。
* **完成済み機能の受け入れテスト**：リグレッション検知用で、やはり常に合格しているべきだ（ただし実行時間は長くなりうる）。
* **新規機能の受け入れテスト**：進行中の作業を表し、機能ができるまで合格しない。

要件が変わったなら、影響を受ける受け入れテストをリグレッション用スイートから進行中のスイートへ戻し、新要件に合わせて編集し、再び合格するようにシステムを変更する。

---

## 最も単純な成功ケースから始める

新しいクラスや機能を書くとき、どこから始めるべきだろう？ 失敗ケースや退化ケースから始めたくなるのはよくあることだ。たしかにそれらはしばしば簡単に見える。XP の格言「可能な限り最もシンプルなことをやれ」[Beck02] の誤解として、単純＝単純化しすぎになってしまうことがある。

私たちは、最も単純な成功ケースから始めるほうを好む。それが動くようになれば、解の本当の構造が見えてきて、途中で気づいた失敗ケースへの対処と、さらなる成功ケースの拡充の優先順位付けがしやすくなる。もちろん、機能は堅牢になってはじめて完成だ。これは失敗処理をサボってよいという言い訳ではない――実装の順番を選べるというだけだ。

キーボードのそばにメモ帳やインデックスカードを置き、失敗ケース、リファクタリング、その他の技術タスクを書き留めておくのが有用だと感じている。これにより、細部を取り落とさずに、目の前のタスクに集中できる。機能は、リストのすべてに線を引いたとき、つまりやるか不要と判断したときにだけ、完了と言える。

---

## 宇宙でのイテレーション

この原稿を書いている今は、初の月面着陸から40周年にあたる頃だ。月計画は、（私たちが扱うよりははるかに大きな賭けだったが）インクリメンタルなアプローチの優れた例だった。1967年には、着陸へ至る道のりとして、次の7つのミッションの系列が提案された。

1. 無人 CSM（司令・機械船）テスト
2. 無人 LM（月着陸船）テスト
3. 有人 CSM（低軌道）
4. 有人 CSM と LM（低軌道）
5. 有人 CSM と LM（近地点は地球、遠地点 4600マイル〔7400km〕の楕円軌道）
6. 有人 CSM と LM（月周回軌道）
7. 有人月面着陸

少なくともソフトウェアでは、私たちは毎回新しいロケットを作らずにインクリメンタルに開発できる。

---

## 読みたくなるテストを書け

各テストは、システム（あるいはオブジェクト）がどんな振る舞いを実行すべきかの、できる限り明確な表現であってほしい。テストを書いている間は、そのテストがまだ実行できない、あるいはコンパイルすらできないという事実はいったん無視し、テキストに集中する。あたかもテスト実行を支えるコードがすでに存在するかのように振る舞うのだ。

テストの読み心地がよくなったら、そのテストを支えるためのインフラを組み立てる。期待どおりの失敗が、明確なエラーメッセージとともに出る段階になれば、支えのコードは十分だと分かる。そこからはじめて、テストを合格させるためのコードを書き始める。テストの読みやすさについては第21章でさらに見る。

## まず落ちるところを見る

私たちはいつも、合格させるコードを書く前に、テストが失敗する様子を実際に見る。そして診断メッセージを確認する。もし想定外の失敗の仕方をするなら、何かを誤解しているか、コードが未完成だ。そこを直す。「正しい」失敗が得られたら、診断が有用かどうかを確かめる。失敗の説明が明瞭でなければ、数週間後にコードが壊れたとき、誰か（たぶん自分）が苦労することになる。エラーメッセージが問題箇所へ導くまで、テストコードを調整しては再実行する（図5.2）。

本番コードを書いている間も、進捗を見るため、そしてシステムがテストの背後で組み上がっていくにつれてエラーダイアグノスティクスが常に明快で関連的であるかを確かめるため、テストを走らせ続ける。

エラーメッセージを確認することにこだわる理由は一つではない。第一に、それは今取り組んでいるコードに関する前提を検証してくれる――ときに私たちは間違っている。第二に、より微妙な点として、私たちが（おそらく強迫的なまでに）意図を表現することを重視する態度は、信頼でき、保守しやすいシステムを開発する上で根本的に重要であり――その中にはテストや失敗メッセージも含まれる、ということだ。役に立つ診断を生み出そうと苦心すること自体が、テスト（ひいてはコード）が何をすべきかを明確化してくれる。エラーダイアグノスティクスの改善は第23章で扱う。

## 入力から出力へ向かって開発する

新しい機能の開発は、その振る舞いを引き起こす外部イベントから考え始める。その機能のエンドツーエンドテストは、これらのイベントの到来をシミュレーションする。システムの境界では、これらのイベントを処理するためのオブジェクトを1つ以上書く必要がある。そうしていくと、これらのオブジェクトが自らの責務を果たすために、システムの他の部分から支援サービスを必要としていることが分かる。私たちはさらにオブジェクトを書いてそのサービスを実装し、今度はその新しいオブジェクトがどんなサービスを必要とするかを明らかにしていく。 

このようにして、私たちはシステムを辿っていく。外部イベントを受け取るオブジェクトから、中間層を抜け、中心的なドメインモデルへ、そして外向きの応答を生成する別の境界オブジェクトへと。これは、テキスト入力とマウスクリックを受け、データベースでレコードを探す、という意味かもしれないし、キューのメッセージを受信してサーバー上のファイルを探す、という意味かもしれない。

新しいドメインモデルのオブジェクトをユニットテストから始め、それをアプリケーションに後からつなぎこもうとする誘惑は強い。最初は簡単に見える――何にも合わせる必要がなければ、ドメインモデル上で急速に進んでいるように感じられる――しかし、後になって統合の問題に噛まれる可能性が高い。適切な種類のフィードバックを受けないまま作業してしまうので、不要または誤った機能を作り込んでしまい、時間を無駄にするだろう。

---

## メソッドではなく「振る舞い」をユニットテストする

私たちは痛い経験から、大量のテストを書いて、高いカバレッジを出したとしても、扱いやすいコードベースが保証されるわけではないと学んだ。TDD を採用した多くの開発者が、後から自分の初期のテストを理解しにくいと感じる。よくある誤りは、メソッドをテストするという発想だ。

testBidAccepted() のようなテスト名は、何をするかは伝えてくれるが、何のためになのかは伝えない。より良いのは、被テスト対象のオブジェクトが提供すべき機能（フィーチャ）に着目することだ。そこでは、隣接するオブジェクトとの協調が必要になったり、複数のメソッド呼び出しが必要になったりするかもしれない。私たちが知るべきなのは、目標を達成するためにそのクラスをどう使うのかであって、コードのすべての経路をどう踏みつぶすかではない。

---

## API 機能ではなく「振る舞い」を記述する重要性

方法ごとにテストを書いていたため、**各オブジェクトの責務やメソッド同士の連携**が**テストから読み取れない**——そんな失敗談があります。**シナリオ中でのふるまい**を表す**テスト名**を選ぶと、**意図が伝わる**ようになります。 

## テストの声に耳を傾ける

経験上、テストが難しいときの最もありそうな原因は、設計の改善が必要なことだ。同じ構造は、いまテストを難しくするだけでなく、将来の変更も難しくする。将来が来る頃には、私たちは当時の考えを忘れている。成功したシステムであれば、意思決定の影響を引き受けるのはまったく別チームかもしれない。

私たちの対応は、テストを書く過程を、保守上の潜在的問題への早期警告として重視し、問題が新しいうちに手当てすることだ。図5.3が示すように、次の失敗するテストを書きにくくなっているなら、プロダクションコードの設計を見直し、しばしばリファクタしてから先へ進む。

これは「予期せぬ変更を予期せよ」という私たちの格言が、開発をどう導くかの一例だ。設計に弱点を見つけたときにリファクタリングを続けてシステムの品質を保てば、どんな変更にも応えられるようになる。対案はありがちな「ソフトウェアの腐敗」で、コードが劣化し、チームが顧客のニーズに応えられなくなるまで進む。第20章でこの話題に戻る。

---

## サイクルの調整

実行パスを網羅的にテストすることと、統合をテストすることの間にはバランスがある。粒度が大きすぎると、すべての経路を試す組合せ爆発で開発が止まる。さらに悪いことに、マイナーな例外スローのように、そのレベルからは実際的にテスト不能なパスもある。一方で、粒度が細かすぎる（クラスレベルだけ等）と、テストは容易になるが、オブジェクト同士がうまく協調できていないことから生じる問題を見逃す。

外部依存を切るためにモックを使ってどこまでユニットテストし、どこまで統合テストするべきか？ 単一の答えはないと考えている。チームや環境の文脈に強く依存するからだ。TDD の「テスト」の側面から得られる最善（しかも大きい）なものは、壊さずに変更できるという自信だ。恐れは前進を殺す。その自信が根拠あるものであるようにするのがコツだ。

そこで私たちは、TDD がどれだけうまく機能しているかを定期的に振り返り、弱点を特定し、戦略を調整する。込み入ったロジックには、より多くのユニットテスト（あるいは単純化）が要るかもしれない。拾えていない例外には、統合レベルのテストが要るかもしれない。予期しないシステム障害には、より広範な調査と、場合によっては全体にわたる追加テストが要るだろう。 

---
