# What Is the Point of Test-Driven Development?

## Software Development as a Learning Process

ソフトウェア開発は学習のプロセス
ほとんどのソフトウェアプロジェクトは、誰もやったことがない（少なくともその組織内では前例のない）ことに挑戦します。その「何か」は、関わる人、アプリケーションドメイン、使用するテクノロジー、あるいはその組み合わせを指します。私たちがどれだけ努力しても、日常的な案件を除けば、たいていのプロジェクトには驚きの要素が含まれます。とりわけ面白いプロジェクト――最大の価値をもたらしうるもの――には、たいてい多くの驚きがあります。

開発者はしばしば、自分が使っているテクノロジーを完全には理解していません。プロジェクトを進めながら、各コンポーネントの動作を学ぶ必要があります。テクノロジーをよく理解している場合でも、新しいアプリケーションが未知の領域に追い込むことがあります。多くの重要なコンポーネントを組み合わせたシステム（つまり、プロのプログラマが扱う大半のもの）は、個人がその可能性のすべてを把握するには複雑すぎます。

顧客やエンドユーザーにとっては、状況はさらに厳しいものになります。システム構築の過程は、これまで以上に自らの組織を精査することを促します。彼らはこれまで慣行や経験に依存していたプロセスを、交渉して明文化せざるを得ない場面にしばしば直面します。

ソフトウェアプロジェクトに関わる全員が、プロジェクトの進行に伴って学習し続ける必要があります。成功のためには、関係者が協力して「何を達成すべきか」を理解し、道中で発生する認識のズレを特定・解消しなければなりません。誰もが変更が起きることは分かっていますが、その中身は分かりません。経験の蓄積とともに不確実性に対処できるプロセス――予期せぬ変更を見越して備えるためのプロセス――が必要です。

---
## Feedback Is the Fundamental Tool
フィードバックは最も基本的な道具です

私たちは、チームにとって最良のアプローチは、実証的なフィードバックを用いてシステムとその利用状況を学び、その学びをシステムに反映することだと考えます。チームには、繰り返しの活動サイクルが必要です。各サイクルで新機能を追加し、すでに行った作業の量と質についてフィードバックを得ます。メンバーは作業をタイムボックスに分割し、その枠内で可能な限り多くの機能を分析・設計・実装・デプロイします。

各サイクルで完了した作業を何らかの環境にデプロイすることは不可欠です。デプロイのたびに、メンバーは自分たちの前提を現実と照らし合わせて検証できます。本当の進捗量を測定し、誤りを検出・修正し、得られた学びに応じて現在の計画を適応させられます。デプロイがなければ、フィードバックは不完全のままです。

私たちの実務では、開発のあらゆるレベルでフィードバックサイクルを適用し、秒から数か月までの入れ子のループとしてプロジェクトを編成します。たとえば、ペアプログラミング、ユニットテスト、受け入れテスト、デイリーミーティング、イテレーション、リリースなどです。各ループはチームのアウトプットを実証的なフィードバックに晒し、誤りや誤解を発見・是正できるようにします。これらのネストしたフィードバックループは互いに補強し合い、もし内側のループを不一致がすり抜けても、外側のループで捉えられる可能性が高まります。

各フィードバックループは、システムや開発プロセスの異なる側面に対応します。内側のループは、コードの単位が何をするか、システムの他部分と統合できているかといった技術的な詳細に焦点を当てます。外側のループは、アプリケーションがユーザーのニーズに応えているか、チームが最大限に効果的に機能しているかといった組織やチーム面に焦点を当てます。

プロジェクトのどの側面であれ、早くフィードバックを得られるほど良い結果につながります。大規模組織の多くのチームは数週間ごとにリリースできます。チームによっては数日、さらには数時間ごとにリリースすることもあり、そのおかげで実ユーザーからのフィードバックを受け取り対応できる機会が桁違いに増えます。

> 増分的かつ反復的な開発

プロジェクトを入れ子のフィードバックループとして編成すると、開発は増分的であり、かつ反復的になります。

増分開発では、すべてのレイヤやコンポーネントを先に作って最後に統合するのではなく、機能ごとにシステムを構築します。各機能は、システムの関連する部分すべてを貫くエンドツーエンドの「スライス」として実装します。システムは常に統合され、デプロイ可能な状態を保ちます。

反復開発では、フィードバックに応じて機能の実装を段階的に洗練し、十分に良い水準に達するまで継続します。
---
## Practices That Support Change

私たちは、システムを信頼性高く成長させ、必ず起こる予期せぬ変更に対処するためには、2つの技術的基盤が必要だと考えます。第1に、回帰エラーを捉えるための継続的なテストが必要です。そうすることで、既存機能を壊さずに新機能を追加できます。ある程度以上の規模のシステムでは、頻繁な手動テストは現実的ではありません。そのため、ビルド・デプロイ・バージョン変更のコストを下げるべく、可能な限りテストを自動化しなければなりません。

第2に、コードは可能な限りシンプルに保つ必要があります。そうすれば理解と修正が容易になります。開発者は書く時間よりも読む時間のほうがはるかに長いのですから、最適化すべきはそこです。1 シンプルさは努力の賜物です。私たちは作業しながら継続的にコードをリファクタリングします [Fowler99]。設計を改善・単純化し、重複を除去し、コードが自分の役割を明確に表現できるようにするためです。フィードバックループにあるテストスイートは、私たちがコードを改善（つまり変更）する際に、自分たちのミスから守ってくれます。

問題は、多くの開発者が自分のコードのテストを書くことを好まない点です。多くの開発現場では、自動テストの作成は機能追加に比べて「本当の仕事」ではない、しかも退屈だ、という見方をされがちです。人は刺激を感じにくい仕事では、期待どおりの成果を出せないものです。

テスト駆動開発（TDD）は、この状況を根本から覆します。私たちはコードを書く前にテストを書きます。作業後の検証としてテストを使うのではなく、TDDはテストを設計活動へと変えます。私たちはテストを使って、コードに何をさせたいのかという考えを明確にします。Kent Beck は私たちにこう説明してくれました。「論理設計と物理設計を、ついに分離できるようになった。ずっとそうすべきだと言われてきたが、誰もやり方を教えてくれなかった」。私たちの実感としても、先にテストを書く努力は、設計アイデアの質についての迅速なフィードバックを与えてくれます。テストしやすいコードにすることが、往々にしてコードをよりクリーンでモジュール化された状態へと導くのです。

開発プロセスの最初から最後までテストを書き続ければ、自動回帰テストというセーフティネットを積み上げることができ、安心して変更を加えられるようになります。

---

## 要点で理解するテスト駆動開発（TDD）

TDD の中心にあるサイクルは、次のとおりです。
>テストを書く → テストを通すためのコードを書く → テストされた機能を可能な限りシンプルに実装するようにリファクタリングする。

これを繰り返します。

システムを開発する間、TDD は実装の品質（「動くか？」）と設計の品質（「構造が良いか？」）の両方についてフィードバックを与えてくれます。テストを先に書くことで、私たちは同じ労力から二重の利益を得られます。

**Writing tests（テストを書くこと）は以下を促します：**

* 次の作業の受け入れ基準を明確化する――つまり、いつ「完了」と言えるかを自問させます（設計）。
* 疎結合なコンポーネントの実装を後押しする。これにより、各コンポーネントを単体で容易にテストでき、さらに上位では組み合わせやすくなります（設計）。
* コードが何をするかの「実行可能な記述」を追加します（設計）。
* 充実した回帰テストスイートに積み増します（実装）。

**whereas running tests（テストを実行すること）は：**

* 文脈が頭に残っているうちにエラーを検出できます（実装）。
* いつ十分にやり切ったかを知らせ、「金メッキ（ゴールドプレーティング）」や不要な機能の追加を抑制します（設計）。

> リファクタリング――ローカルに考え、ローカルに行動する

リファクタリングとは、振る舞いを変えずに既存コードの内部構造を変更することを指します。目的は、実装している機能をよりよく表現するコードへ改善し、保守しやすくすることです。リファクタリングは規律ある手法であり、プログラマは振る舞いを変えない一連の変換（「リファクタリング」）を適用します。各リファクタリングは小さく、理解しやすく「安全」であるべきです。たとえば、あるコードブロックをヘルパーメソッドに抽出して、元のメソッドを短くして読みやすくする、といった具合です。各ステップの後でシステムが依然として動作することを確認し、変更によって行き詰まるリスクを最小化します。テスト駆動のコードでは、テストを実行することでこれを行えます。

リファクタリングは、小規模な改良を積み上げる「ミクロな技法」です。私たちの経験では、厳密かつ継続的に適用すれば、多数の小さなステップが大きな構造改善へとつながります。リファクタリングは再設計とは同じ活動ではありません。再設計は、大域的な構造を変更するという意識的な判断を伴います。ただし、再設計の方針を決めた後、その新しい設計へ段階的かつ安全に到達するための手段として、リファクタリング技法を用いることができます。

Part III の例では、多くのリファクタリングを目にするでしょう。この概念の標準的な文献は Fowler の [Fowler99] です。

このフィードバックサイクルは、TDD の黄金律（Golden Rule）で要約できます：

---

## より大きな視点

TDD を始めるにあたって、アプリケーション内のクラスに対するユニットテストから書き始めたくなるものです。これはテストがまったくない状態よりははるかに良く、誰もが知っていながら避けにくい基本的なプログラミングエラー――フェンスポストエラー（オフバイワン）や誤ったブール式など――を検出できます。しかし、ユニットテストだけのプロジェクトは、TDD プロセスの重要な利点を取り逃がしています。私たちは、コードの品質が高くユニットテストも充実しているのに、どこからも呼ばれておらず、あるいはシステムの他の部分と統合できずに書き直しを迫られたプロジェクトを目にしてきました。

どこからコードを書き始めればよいのでしょうか？ さらに重要なのは、いつコードを書くのを止めればよいのでしょうか？ 黄金律が教えてくれます。
**失敗するテストを書きましょう。**

機能を実装するときは、まず受け入れテストを書き、そのテストが対象とする機能を実行させます。テストが失敗している間は、その機能がまだシステムに実装されていないことを示します；テストが通れば、そこで完了です。機能の作業中は、その受け入れテストを手掛かりに、これから書こうとしているコードが本当に必要かを判断し、**直接関係するコードだけ**を書きます。その下では、ユニットレベルの「テスト→実装→リファクタリング」サイクルに従って機能を作り込みます。

外側のテストループは、実証可能な進捗の物差しであり、増え続けるテストスイートは、システムを変更した際の回帰不具合から私たちを守ってくれます。受け入れテストがグリーンになるまでには時間がかかることが多く、1 回のチェックインで収まらないのが普通です。そこで私たちは、現在取り組み中の受け入れテスト（まだビルドには含めない）と、完了済みの機能の受け入れテスト（ビルドに含め、常にパスしなければならない）を区別するのが通例です。

内側のループは開発者を支援します。ユニットテストはコードの品質維持に役立ち、書いて間もなくパスするべきです。失敗しているユニットテストをソースリポジトリにコミットしてはなりません。

---

## エンドツーエンドでテストする

可能なかぎり、受け入れテストはシステムの内部コードを直接呼び出さず、エンドツーエンド（end-to-end）でシステムを行使すべきです。エンドツーエンドテストは、ユーザーインターフェース経由、外部システムからのメッセージ送信のシミュレーション、Web サービスの呼び出し、レポートの解析など、**外部**からのみシステムと対話します。第10章で述べるとおり、システムの全体的なふるまいには外部環境との相互作用も含まれます。ここはしばしば最もリスクが高く、最も難しい側面であり、無視すると痛い目に遭います。すでに安定したエンドツーエンドテスト一式がカバーとして存在し、かつ速度向上が本当に必要な場合を除き、システムの内部オブジェクトだけを行使する受け入れテストは避けるようにします。

私たちにとって「エンドツーエンド」とは、単に外部からシステムに触れる以上の意味を持ちます――それはむしろ「エッジツーエッジ」テストと呼ぶべきでしょう。私たちは、エンドツーエンドテストが**システム本体**だけでなく、それが**ビルド・デプロイされるプロセス**まで行使することを好みます。自動ビルドは、通常は誰かがソースリポジトリにコードをチェックインすることでトリガーされ、次を実行します：最新バージョンのチェックアウト、コードのコンパイルとユニットテスト、システムの統合とパッケージング、本番に近い現実的な環境へのデプロイ、そして最後に外部のアクセスポイント経由でのシステム行使。聞くだけでも手間がかかりそうですが（実際に手間です）、ソフトウェアのライフタイムを通じて繰り返し必要になります。多くのステップは煩雑でエラーが起きやすいため、エンドツーエンドのビルドサイクルは自動化に最適です。第10章では、プロジェクトのかなり初期段階でこれを稼働させる方法を示します。

受け入れテストがすべてパスしたとき、そのシステムはデプロイ可能だと言えます。というのも、それで「すべてが動いている」という十分な確信が得られるべきだからです。ただし最後には本番デプロイのステップが残ります。多くの組織、特に大規模または厳格に規制された組織では、デプロイ可能なシステムを作ることはリリースプロセスの**始まり**に過ぎません。エンドユーザーに新機能が届くまでの残りの工程には、さまざまな種類のテスト、運用・データ部門への引き継ぎ、他チームのリリースとの調整が含まれることがあります。さらに、トレーニングやマーケティング、停止時間に関するサービス合意への影響など、非技術的コストも発生し得ます。結果として、理想よりも難しいリリースサイクルになります。したがって、技術面と組織面を含む自分たちの全体環境を理解しておく必要があります。

> エンドツーエンドテストの重要性：ある恐怖譚

Nat は、立ち上げ当初から TDD を採用していたプロジェクトに参加したことがあります。チームは要件を捕捉し顧客代表に進捗を示すため、受け入れテストを書いていました。システムのクラスに対してユニットテストも書いており、内部はクリーンで変更しやすい状態でした。進捗は順調で、受け入れテストがパスしたことを根拠に、顧客代表はすべての実装済み機能にサインオフしていました。

しかし、その受け入れテストはエンドツーエンドではありませんでした――システムの内部オブジェクトを生成し、そのメソッドを直接呼び出していたのです。実際のアプリケーションは**何もしていません**でした。エントリポイントには次の1行コメントしかありませんでした。

```
// TODO implement this
```

定期的なショー・アンド・テルのような追加のフィードバックループがあれば、この問題は早期に発見できたはずです。

---
## External and Internal Quality

テストから得られる示唆には、別の見方があります。外部品質と内部品質を区別して考えることです。**外部品質**は、システムが顧客やユーザーのニーズをどれだけ満たしているか（機能性、信頼性、可用性、応答性など）を指し、**内部品質**は、開発者や管理者のニーズをどれだけ満たしているか（理解しやすさ、変更しやすさなど）を指します。外部品質の重要性は誰にでも理解できますし、通常は契約の一部にもなります。一方で内部品質の重要性は同等であるにもかかわらず、主張しにくいことが多いです。内部品質こそが、継続的かつ予期せぬ変更に対処する力を与えてくれます。これは本章の冒頭で見たとおり、ソフトウェア開発における事実です。内部品質を維持する目的は、システムの振る舞いを安全かつ予測可能に変更できるようにすることです。そうすることで、ある変更が大規模な作り直しを招くリスクを最小化できます。

エンドツーエンドテストを実行することで、システムの外部品質についての情報が得られます。また、それらを書くこと自体が、チーム全体としてドメインをどれだけ理解しているかの手がかりにもなります。しかし、エンドツーエンドテストは、コードをどれだけ上手く書けているかまでは教えてくれません。ユニットテストは、コード品質に関する多くのフィードバックを与えてくれ、実行すればクラスを壊していないことを確認できます。しかし、やはりユニットテストだけでは、システム全体が正しく動くという十分な確信には至りません。**統合テストはその中間に位置します。**

徹底したユニットテストは内部品質の向上に役立ちます。というのも、テストするには、ユニットをシステムの外でテストフィクスチャ上で実行できるように構造化する必要があるからです。オブジェクトのユニットテストでは、そのオブジェクトを生成し、依存関係を与え、相互作用し、期待どおりに振る舞ったかを検証します。したがって、クラスをユニットテストしやすくするには、置き換えやすい**明示的な依存関係**を持ち、呼び出しや検証が容易な**明確な責務**を持っていなければなりません。ソフトウェア工学の用語で言えば、コードは**疎結合**かつ**高凝集**であるべき、言い換えれば**良い設計**であるべきなのです。

これに反している場合――たとえば、あるクラスがシステムの遠く離れた部分に**強く結合**していたり、**暗黙の依存関係**を持っていたり、あるいは責務が多すぎる／不明瞭であったりすると――ユニットテストは書きづらく、理解もしづらくなります。そこで**先にテストを書く**ことは、設計に関する貴重で即時のフィードバックを与えてくれます。誰しも、コードがテストしづらいとテストを書くのを避けたくなりますが、私たちはそれに抗うよう努めます。こうした困難を、なぜテストが書きにくいのかを調査し、**リファクタリング**によって構造を改善する機会として捉えます。これを私たちは「**テストの声を聞く**」と呼び、第20章でよくあるパターンを扱います。

---

